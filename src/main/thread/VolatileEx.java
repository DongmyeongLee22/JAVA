package main.thread;

/*
    멀티 코어 프로세서가 장착된 컴퓨터를 사용하면 코어별로 캐시값을 가지고 있다.

    ** 코어는 메모리에서 읽어온 값을 캐시에 저장하고 캐시에서 값을 읽어서 작업한다. 다시 같은 값을 읽어올 때는 먼저 캐시에
    있는지 확인하고 없을 때만 메모리에서 읽어온다. **
    그러다 보니 도중에 메모리에 저장된 변수의 값이 변경되었는데로 캐시에 저장된 값이 갱신 되지않아 문제가 발생할 수 있다.
    이럴때 volatile 을 이용하면 코어가 변수를 읽어올때 캐시가 아닌 메모리에서 읽어오므로 캐시와 메모리간의 불일치가 해소된다.

    volatile 대신에 synchronized(블럭을 나올때 캐시와 메모리간의 동기화 이루어짐)
    는 사용가능하다. 그러나 synchronized 대신 volatile은 불가능하다.

    -> 한 명령어로 32bit까지 처리가능
    JVM은 데이터를 4byte(32bit) 단위로 처리하기 때문에 long, double등 크기가 8byte인 변수들은 하나의 명령어로 값을
    읽거나 쓸수 없다. 그렇기 때문에 다른 쓰레드가 끼어 들수도 있다. 이럴때 volatile을 사용하여 원자화하면 된다.

 */
public class VolatileEx {
    volatile long tets1;
    volatile double test1;


}
